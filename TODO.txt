0) Предварительное объявление всех функций.
0) 
	Func
	{
		s.1 e.1, HeadSwap<e.1 s.1> : c b d = Success;
	}

	Порождает код:
		funcTerm->funcCall->funcName = "";
		funcTerm->funcCall->funcPtr = ;
0) Тесты для связанных переменных
0) Тесты для цепочек действий (несколько образцов, сборок и т.д.)
0) Сравнение float значений
0) Избавиться от ужасов типа: int(term.Value.Int.Int64()), string(term.Value.Str)
1) Узнать про вызов функций:
	$ENTRY Go
	{
	 	= <Prout<Func1 Dummy Func2 'Ehohhoo!!!'>>
	}

	Func1
	{
		s.1 s.2 e.1 = <s.2>
	}

	Func2
	{
		= 'Hello, world!!!'
	}
  
   Должно ли это работать?

2) 

-Проверить: Сопоставление с образцом "ломает" скобочные выражения. e.1 может сопоставиться с (a s d или a s)
-Встроенные функции
-Память для lterm'ов должна выделяться в куче. Так как неизвестно когда они будут освобождены.
-Оптимизировать количество переменных по предложениям в locals.

